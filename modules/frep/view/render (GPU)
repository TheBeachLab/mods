//
// view frep volume renderer
//
// Neil Gershenfeld 
// (c) Massachusetts Institute of Technology 2016
// 
// This work may be reproduced, modified, distributed, performed, and 
// displayed for any purpose, but must acknowledge the mods
// project. Copyright is retained and must be preserved. The work is 
// provided as is; no warranty is provided, and users accept all 
// liability.
//
//
// closure
//
(function(){
//
// module globals
//
var mod = {};
//
// name
//
var name = 'render GPU';
//
// initialization
//
var init = function() {
	mod.steps.value=256.0;
	mod.alphaCorrection.value=1.0;
	mod.rendType=0.0;
	mod.windowOpen=false;
	mod.xLimit1 =-1.0 ;
	mod.xLimit2 =1.0 ; 
	mod.yLimit1 =-1.0 ; 
	mod.yLimit2 =1.0 ; 
	mod.zLimit1 =-1.0 ; 
	mod.zLimit2 =1.0 ;
   };
//
// inputs
//
var inputs = {
	shape:{type:'frep',
	event:function(evt){

		mod.shape=evt.detail;

		// outputs.messageLog.event(mod.shape.limits);

		//get largerst range and rescale other ones to adjust limit mapping
		var tempIndex=0;
		var tempMax=-1.0;

		for(i=0;i<mod.shape.limits.length;i++)
		{
			if((mod.shape.limits[i][1]-mod.shape.limits[i][0]) >= tempMax )
			{
				tempIndex=i;
				tempMax=mod.shape.limits[i][1]-mod.shape.limits[i][0];
			}
		}
		for(i=0;i < mod.shape.limits.length;i++)
		{
			if(i!=tempIndex)
			{
				var tempDif = (mod.shape.limits[tempIndex][1]-mod.shape.limits[tempIndex][0])-(mod.shape.limits[i][1]-mod.shape.limits[i][0]);
				mod.shape.limits[i][0]-=tempDif/2.0;
				mod.shape.limits[i][1]+=tempDif/2.0;
				
			}
		}

		mod.xLimit1=mod.shape.limits[0][0] ;
		mod.xLimit2=mod.shape.limits[0][1] ; 
		mod.yLimit1=mod.shape.limits[1][0] ; 
		mod.yLimit2=mod.shape.limits[1][1] ; 
		mod.zLimit1=mod.shape.limits[2][0] ; 
		mod.zLimit2=mod.shape.limits[2][1] ;
		

		//
		//turn function string to gsls
		//
		var str1 = mod.shape.function;
		str1=str1.replace(/Math./g, '');
			
		//change all % to mod(,)
		while(str1.indexOf("%")>-1) //While '%' is there
		{
			//get location
			var modLocation=str1.indexOf("%");
			//replace with ','
			str1=str1.replace(/%/, ",");
			outputs.messageLog.event("1:"+str1);

			//parse before
			var counterBefore=modLocation;
			var count=0;
			if(str1[--counterBefore]==')')
			{
				count++;
			}
			while(count>0)
			{
				counterBefore--;
				if(str1[counterBefore]==')')
				{
					count++;

				}else if (str1[counterBefore]=='(')
				{
					count--;
				}
			}
			
			//parse after
			var counterAfter=modLocation;
			count=0;
			if(str1[++counterAfter]=='(')
			{
				count++;
			}
			while(count>0)
			{
				counterAfter++;
				if(str1[counterAfter]=='(')
				{
					count++;

				}else if (str1[counterAfter]==')')
				{
					count--;
				}
			}
			str1 = str1.substr(0, counterAfter) + ")" + str1.substr(counterAfter);
			str1 = str1.substr(0, counterBefore) + "mod(" + str1.substr(counterBefore);
			outputs.messageLog.event("2"+str1);

		}

		//turn all ints to floatS
		var str='';
		for(var i=0;i<str1.length;i++)
		{
			//if number
			if(!isNaN(str1[i]))
			{
				str+=str1[i];
				//check next value
				for(var j=i+1;j<str1.length;j++)
				{
				//if number add and continue
				if(!isNaN(str1[j])) 
				{
					str+=str1[j];
					i=j;
				}
				//else if dot add and add numbers till NaN
				else if(str1[j]=='.')
				{
					str+=str1[j];
					i=j;
					//add till not num
					for(var k=j+1;k<str1.length;k++)
					{
						if(!isNaN(str1[k]))
						{
							str+=str1[k];
							i=k;
						}
						else
						{
							k=str1.length;
						}
					}
					j=str1.length;
				}
				//else add .0 and go to next number
				else
				{
					str+='.';
					str+='0';
					j=str1.length;
				}
				}

			}
			else
			{
				str+=str1[i];
			}
		}
		// outputs.messageLog.event(str);
		mod.str=str;

		//if window open update shader function
		if(mod.windowOpen)
		{
			mod.updateShaderFunction();
		}

	   }}};
//
// outputs
//
var outputs = {
    messageLog:{type:'string',
      event:function(mess){
         //mess='hshs' 
        mods.output(mod,'messageLog',mess);
      }
    }
}
//
// interface
//
var interface = function(div){
   mod.div = div
   //
   // resolution
   //
   div.appendChild(document.createTextNode('resolution: '));
   var input = document.createElement('input');
      input.type = 'text';
      input.size = 3;
      input.addEventListener('input',function(){
			if(mod.windowOpen)
			{
				mod.redraw();
			}
         });
      div.appendChild(input);
      mod.steps = input;
   div.appendChild(document.createElement('br'));
   //
   // alpha correction
   //
   div.appendChild(document.createTextNode('Alpha Correction: '));
   var input = document.createElement('input');
      input.type = 'text';
      input.size = 3;
      input.addEventListener('input',function(){
			if(mod.windowOpen)
			{
				mod.redraw();
			}
         });
      div.appendChild(input);
      mod.alphaCorrection = input;
   div.appendChild(document.createElement('br'));
   //
   // rendering style
   //
   div.appendChild(document.createTextNode('rendering style: '))
            var input = document.createElement('SELECT');
            
			input.setAttribute("id", "rend-select");
			
			//select menu for functions
			var z = document.createElement("option");
			z.setAttribute("value", "0");
			var t = document.createTextNode('specular');
			z.appendChild(t);
			input.appendChild(z);

			var z = document.createElement("option");
			z.setAttribute("value", "1");
			var t = document.createTextNode('height map');
			z.appendChild(t);
			input.appendChild(z);

			var z = document.createElement("option");
			z.setAttribute("value", "2");
			var t = document.createTextNode('xray');
			z.appendChild(t);
			input.appendChild(z);

			var z = document.createElement("option");
			z.setAttribute("value", "3");
			var t = document.createTextNode('normals');
			z.appendChild(t);
			input.appendChild(z);

			var z = document.createElement("option");
			z.setAttribute("value", "4");
			var t = document.createTextNode('light');
			z.appendChild(t);
			input.appendChild(z);
		 
			input.addEventListener('change',function(evt){
				var temp= document.getElementById("rend-select");
				mod.rendType=parseFloat(temp.value);
				outputs.messageLog.event(mod.rendType);
				mod.updateShaderFunction();
            });

			div.appendChild(input);

			// outputs.messageLog.event(input);

	div.appendChild(document.createElement('br'));
   //
   // view
   //   
   div.appendChild(document.createElement('br'))  ; 
   var btn = document.createElement('button');
      btn.style.padding = mods.ui.padding;
      btn.style.margin = 1;
      var span = document.createElement('span');
         var text = document.createTextNode('view');
            span.appendChild(text);
         btn.appendChild(span);
      btn.addEventListener('click',function(){
		mod.windowOpen=true; 
         open_view_window();
         });
      div.appendChild(btn);
   }
//
// local functions
//
 
//
// open_view_window
//
function open_view_window() {
   //
   // globals
   //
    var container;
    var camera, sceneFirstPass, sceneSecondPass, renderer;
	var clock ; // do i need it
	var rtTexture;
	var materialSecondPass;
	var center;
	var meshSecondPass;
	var boxGeometry;
   //
   // get function
   //
   
   //
   //add shader script
   //
   addShaderScripts();
   //
   // open the window
   //
   open_window();
   
   //
   // open_window
   //
   function open_window() {
      //
      // open window
	  //
	  
      win = window.open('');
      mod.win = win;
      //
      // load three.js
      //
      var script = document.createElement('script');
      script.type = 'text/javascript';
      script.onload = init_window;
      script.src = 'js/three.js/three.min.js';
      mod.div.appendChild(script);
	  }
   //
   // add shader scripts
   //
   function addShaderScripts() {

	/////////////////////////fragmentShaderFirstPass////////////////////////////////////

    var div = document.createElement('script');

	div.id = 'fragmentShaderFirstPass';
	div.type = 'x-shader/x-fragment';

    div.innerHTML =
		`
			varying vec3 worldSpaceCoords;

			void main()
			{
				//The fragment's world space coordinates as fragment output.
				gl_FragColor = vec4( worldSpaceCoords.x , worldSpaceCoords.y, worldSpaceCoords.z, 1 );
			}
			`;
	
	//
	mod.div.appendChild(div);
	
	/////////////////////////vertexShaderFirstPass////////////////////////////////////
	var div = document.createElement('script');

	div.id = 'vertexShaderFirstPass';
	div.type = 'x-shader/x-vertex';

    div.innerHTML =
		`
			varying vec3 worldSpaceCoords;

			void main()
			{
				//Set the world space coordinates of the back faces vertices as output.
				worldSpaceCoords = position + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
			`;
	
	//
	mod.div.appendChild(div);
	/////////////////////////fragmentShaderSecondPass////////////////////////////////////
	var div = document.createElement('script');

	div.id = 'fragmentShaderSecondPass';
	div.type = 'x-shader/x-fragment';

    
	div.innerHTML=fragmentShaderSecondPass();
	mod.div.appendChild(div);

	/////////////////////vertexShaderSecondPass///////////////////
	var div = document.createElement('script');

	div.id = 'vertexShaderSecondPass';
	div.type = 'x-shader/x-vertex';

    div.innerHTML =
		`
			varying vec3 worldSpaceCoords;
			varying vec4 projectedCoords;

			void main()
			{
				worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;
				gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );
				projectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
			`;
	//
	mod.div.appendChild(div);

	}

	function fragmentShaderSecondPass()
	{
		var txt =
			`
				varying vec3 worldSpaceCoords;
				varying vec4 projectedCoords;
				uniform sampler2D tex;
				uniform float steps;
				uniform float alphaCorrection;
				uniform float rendType;
				// The maximum distance through our rendering volume is sqrt(3).
				// The maximum number of steps we take to travel a distance of 1 is 512.
				// ceil( sqrt(3) * 512 ) = 887
				// This prevents the back of the image from getting cut off when steps=512 & viewing diagonally.
				const int MAX_STEPS = 887;
				uniform float xLimit1;
				uniform float xLimit2;
				uniform float yLimit1;
				uniform float yLimit2;
				uniform float zLimit1;
				uniform float zLimit2;
				float orgMin=0.0;
				float orgMax=1.0;
				vec3 viewDirection;


				float map(vec3 p)
				{
					float X= p.x;
					float Y= p.y;
					float Z= p.z;

					return `+mod.str+`;
				}
				vec3 simpleLambert (vec3 normal) {
					vec3 lightDir = vec3(20.0,40.0,-40.0);	// Light direction
					vec3 lightCol = vec3(1.0,1.0,1.0);		// Light color
					vec3 _Color=vec3(0.2,0.5,1.0);
				
					float NdotL = max(dot(normal, lightDir),0.0);
					vec3 c;
					c.rgb = _Color * lightCol * NdotL;
					return c;
				}
				vec3 specular (vec3 normal) {
					vec3 lightDir = vec3(20.0,40.0,-40.0);	// Light direction
					vec3 lightCol = vec3(1.0,1.0,1.0);		// Light color
					vec3 _Color=vec3(0.2,0.5,1.0);
					
					float _SpecularPower=0.5;
					float _Gloss=0.5;
				
					float NdotL = max(dot(normal, lightDir),0.0);
					vec3 c;
					vec3 h = (lightDir - viewDirection) / 2.0;
					float s = pow( dot(normal, h), _SpecularPower) * _Gloss;
					c.rgb = _Color * lightCol * NdotL + s;
					return c;
				}

				//Acts like a texture3D using Z slices and trilinear filtering.
				vec4 sampleAs3DTextureCustom( vec3 texCoord )
				{ 
					float X= (texCoord.x - orgMin) * (xLimit2 - xLimit1) / (orgMax - orgMin) + xLimit1;
					float Y= (texCoord.y - orgMin) * (yLimit2 - yLimit1) / (orgMax - orgMin) + yLimit1;
					float Z= (texCoord.z - orgMin) * (zLimit2 - zLimit1) / (orgMax - orgMin) + zLimit1;

					//slice color red
					vec4 m;
					m=vec4(0.0,0.0,0.0,0.0);

					
					if(`+mod.str+`>0.0)
					{
						m.a=1.0;
						//xray
						if(rendType==2.0)
						{
							m=vec4(1.0,1.0,1.0,0.1);
						}
						//heightmap fixed
						else if(rendType==1.0)
						{
							//heightmap
							m.r=texCoord.z;
							m.g=texCoord.z;
							m.b=texCoord.z;
						}
						// //normal
						else if(rendType==3.0)
						{
							const float eps = 0.5;
							vec3 p=vec3(X,Y,Z);
							m.r=map(p + vec3(eps, 0, 0)	) - map(p - vec3(eps, 0, 0));
							m.g=map(p + vec3(0, eps, 0)	) - map(p - vec3(0, eps, 0));
							m.b=map(p + vec3(0, 0, eps)	) - map(p - vec3(0, 0, eps));

						}
						//light
						else if(rendType==0.0)
						{
							const float eps = 0.01;
							vec3 p=vec3(X,Y,Z);
							float tempConst=0.05;
							m.r=map(p + vec3(eps, 0, 0)	) - map(p - vec3(eps, 0, 0));
							m.g=map(p + vec3(0, eps, 0)	) - map(p - vec3(0, eps, 0));
							m.b=map(p + vec3(0, 0, eps)	) - map(p - vec3(0, 0, eps));

							m.rgb=simpleLambert (m.rgb)+tempConst;

						}
						//specular
						else if(rendType==4.0)
						{
							const float eps = 0.01;
							vec3 p=vec3(X,Y,Z);
							float tempConst=0.05;

							m.r=map(p + vec3(eps, 0, 0)	) - map(p - vec3(eps, 0, 0));
							m.g=map(p + vec3(0, eps, 0)	) - map(p - vec3(0, eps, 0));
							m.b=map(p + vec3(0, 0, eps)	) - map(p - vec3(0, 0, eps));

							m.rgb=specular (m.rgb)+tempConst;

						}
					}
					return m ;
				}
				
				void main( void ) {

					//Transform the coordinates it from [-1;1] to [0;1]
					vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,
									((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0 );

					//The back position is the world space position stored in the texture.
					vec3 backPos = texture2D(tex, texc).xyz;

					//The front position is the world space position of the second render pass.
					vec3 frontPos = worldSpaceCoords;

					//The direction from the front position to back position.
					vec3 dir = backPos - frontPos;
					

					float rayLength = length(dir);

					//Calculate how long to increment in each step.
					float delta = 1.0 / steps;

					//The increment in each direction for each step.
					vec3 deltaDirection = normalize(dir) * delta;

					viewDirection=deltaDirection;//amira added

					float deltaDirectionLength = length(deltaDirection);

					//Start the ray casting from the front position.
					vec3 currentPosition = frontPos;

					//The color accumulator.
					vec4 accumulatedColor = vec4(0.0);

					//The alpha value accumulated so far.
					float accumulatedAlpha = 0.0;

					//How long has the ray travelled so far.
					float accumulatedLength = 0.0;

					//If we have twice as many samples, we only need ~1/2 the alpha per sample.
					//Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.
					float alphaScaleFactor = 25.6 * delta;

					vec4 colorSample;
					float alphaSample;

					//Perform the ray marching iterations
					for(int i = 0; i < MAX_STEPS; i++)
					{
						//Get the voxel intensity value from the 3D texture.
						colorSample = sampleAs3DTextureCustom( currentPosition );

						//Allow the alpha correction customization.
						alphaSample = colorSample.a * alphaCorrection;

						//Applying this effect to both the color and alpha accumulation results in more realistic transparency.
						alphaSample *= (1.0 - accumulatedAlpha);

						//Scaling alpha by the number of steps makes the final color invariant to the step size.
						alphaSample *= alphaScaleFactor;

						//Perform the composition.
						accumulatedColor += colorSample * alphaSample;

						//Store the alpha accumulated so far.
						accumulatedAlpha += alphaSample;

						//Advance the ray.
						currentPosition += deltaDirection;
						accumulatedLength += deltaDirectionLength;

						//If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.
						if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )
							break;
					}

					gl_FragColor  = accumulatedColor;

				}
				`;
		return txt;
	}

//
   //
   // init_window
   //
function init_window() {
      //
      // close button
      //
      var btn = document.createElement('button');
         btn.appendChild(document.createTextNode('close'));
         btn.style.padding = mods.ui.padding;
         btn.style.margin = 1;
         btn.addEventListener('click',function(){
            win.close()
            mod.win = undefined;
            })
         win.document.body.appendChild(btn)
      //
      // label text
      //
      var text = win.document.createTextNode(' left: pan, right: rotate, scroll: zoom');
         win.document.body.appendChild(text);
      //
      // GL container
      //
      win.document.body.appendChild(document.createElement('br')) ;  
      container = win.document.createElement('div');
      container.style.overflow = 'hidden';
      win.document.body.appendChild(container);
      
	  //
	  //
	
	clock = new THREE.Clock(); //do i need it?
	center= new THREE.Vector3(0,0,0);
	//
	// add camera
	//
	camera = new THREE.PerspectiveCamera( 40, win.innerWidth / win.innerHeight, 0.01, 3000.0 );
	camera.position.z = 2.0;
	 
	var screenSize = new THREE.Vector2( win.innerWidth, win.innerHeight );
	rtTexture = new THREE.WebGLRenderTarget( screenSize.x, screenSize.y,
											{ 	minFilter: THREE.LinearFilter,
												magFilter: THREE.LinearFilter,
												wrapS:  THREE.ClampToEdgeWrapping,
												wrapT:  THREE.ClampToEdgeWrapping,
												format: THREE.RGBAFormat,
												type: THREE.FloatType,
												generateMipmaps: false} );


	var materialFirstPass = new THREE.ShaderMaterial( {
		vertexShader: document.getElementById( 'vertexShaderFirstPass' ).textContent,
		fragmentShader: document.getElementById( 'fragmentShaderFirstPass' ).textContent,
		side: THREE.BackSide
	} );

	var lookAtVector = new THREE.Vector3(0,0, -1);
	lookAtVector.applyQuaternion(camera.quaternion);	

	materialSecondPass = new THREE.ShaderMaterial( {
		vertexShader: document.getElementById( 'vertexShaderSecondPass' ).textContent,
		fragmentShader: document.getElementById( 'fragmentShaderSecondPass' ).textContent,
		side: THREE.FrontSide,
		uniforms: {	tex:  { type: "t", value: rtTexture },
					steps : {type: "1f" , value: mod.steps.value }, 
					rendType : {type: "1f" , value: mod.rendType},
					xLimit1 : {type: "1f" , value: mod.xLimit1 }, 
					xLimit2 : {type: "1f" , value: mod.xLimit2 }, 
					yLimit1 : {type: "1f" , value: mod.yLimit1 }, 
					yLimit2 : {type: "1f" , value: mod.yLimit2 }, 
					zLimit1 : {type: "1f" , value: mod.zLimit1 }, 
					zLimit2 : {type: "1f" , value: mod.zLimit2 }, 
					alphaCorrection : {type: "1f" , value: mod.alphaCorrection.value }}
		});

	
	//outputs.messageLog.event('s');

	sceneFirstPass = new THREE.Scene();
	sceneSecondPass = new THREE.Scene();

	boxGeometry = new THREE.BoxGeometry(1.0, 1.0, 1.0);
	boxGeometry.doubleSided = true;

	var meshFirstPass = new THREE.Mesh( boxGeometry, materialFirstPass );
	meshSecondPass = new THREE.Mesh( boxGeometry, materialSecondPass );

	sceneFirstPass.add( meshFirstPass );
	sceneSecondPass.add( meshSecondPass );

	renderer = new THREE.WebGLRenderer();
	container.appendChild( renderer.domElement );

	//camera and controls
	camera.aspect = win.innerWidth / win.innerHeight;
	camera.up = new THREE.Vector3(0, 0, 1);
	camera.position.x = 5;
	camera.lookAt(new THREE.Vector3(0,0,0));
	camera.updateProjectionMatrix();
	var Controls = (function(Controls) {
		// "use strict";
	
		// Check for double inclusion
		if (Controls.addMouseHandler)
			return Controls;
	
		Controls.addMouseHandler = function (domObject, drag, zoomIn, zoomOut) {
			var startDragX = null,
				startDragY = null;
	
			function mouseWheelHandler(e) {
				e = window.event || e;
				var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
	
				if (delta < 0 && zoomOut) {
					zoomOut(delta);
				} else if (zoomIn) {
					zoomIn(delta);
				}
	
				e.preventDefault();
			}
	
			function mouseDownHandler(e) {
				startDragX = e.clientX;
				startDragY = e.clientY;
	
				e.preventDefault();
			}
	
			function mouseMoveHandler(e) {
				if (startDragX === null || startDragY === null)
					return;
	
				if (drag)
					drag(e.clientX - startDragX, e.clientY - startDragY);
	
				startDragX = e.clientX;
				startDragY = e.clientY;
	
				e.preventDefault();
			}
	
			function mouseUpHandler(e) {
				mouseMoveHandler.call(this, e);
				startDragX = null;
				startDragY = null;
	
				e.preventDefault();
			}
	
			domObject.addEventListener("mousewheel", mouseWheelHandler);
			domObject.addEventListener("DOMMouseScroll", mouseWheelHandler);
			domObject.addEventListener("mousedown", mouseDownHandler);
			domObject.addEventListener("mousemove", mouseMoveHandler);
			domObject.addEventListener("mouseup", mouseUpHandler);
		};
		return Controls;
	}(Controls || {}));
	Controls.addMouseHandler(renderer.domElement, drag, zoomIn, zoomOut);
	

	renderer.setSize( win.innerWidth, win.innerHeight );

	win.addEventListener( 'resize', onWindowResize, false );
	
	 //animate();
	 render();
	}
  
  
	/////////////// 
	function onWindowResize( event ) {

		//TODO: Fix box white edge when window resize
		renderer.setSize( win.innerWidth, win.innerHeight );

		camera.aspect = win.innerWidth / win.innerHeight;
		camera.updateProjectionMatrix();

		redraw();
	}

    ////////////////
	function animate() {
		requestAnimationFrame( animate );
		render();
	}

	/////////
	function redraw(){
		render();
	}
	mod.redraw=redraw;

    //////////////////
	function render() {

		var delta = clock.getDelta();

		var lookAtVector = new THREE.Vector3(0,0, -1);
		lookAtVector.applyQuaternion(camera.quaternion);

		materialSecondPass.uniforms.steps.value = mod.steps.value;
		materialSecondPass.uniforms.alphaCorrection.value = mod.alphaCorrection.value;
		materialSecondPass.uniforms.rendType.value=mod.rendType;
		materialSecondPass.uniforms.xLimit1.value =mod.xLimit1 ;
		materialSecondPass.uniforms.xLimit2.value =mod.xLimit2 ; 
		materialSecondPass.uniforms.yLimit1.value =mod.yLimit1 ; 
		materialSecondPass.uniforms.yLimit2.value =mod.yLimit2 ; 
		materialSecondPass.uniforms.zLimit1.value =mod.zLimit1 ; 
		materialSecondPass.uniforms.zLimit2.value =mod.zLimit2 ;

		//Render first pass and store the world space coords of the back face fragments into the texture.
		renderer.render( sceneFirstPass, camera, rtTexture, true );

		//Render the second pass and perform the volume rendering.
		renderer.render( sceneSecondPass, camera );

		
		 
	}

	//
	//when fuction changes
	function updateShaderFunction()
	{
		// outputs.messageLog.event('update shader');
		
		// outputs.messageLog.event(mod.xLimit1);

		var div = document.getElementById('fragmentShaderSecondPass');

		div.innerHTML="";
		div.innerHTML =fragmentShaderSecondPass();
		
		var lookAtVector = new THREE.Vector3(0,0, -1);
		lookAtVector.applyQuaternion(camera.quaternion);

		// outputs.messageLog.event('update shader1');
		materialSecondPass = new THREE.ShaderMaterial( {
			vertexShader: document.getElementById( 'vertexShaderSecondPass' ).textContent,
			fragmentShader: document.getElementById( 'fragmentShaderSecondPass' ).textContent,
			side: THREE.FrontSide,
			uniforms: {	tex:  { type: "t", value: rtTexture },
						steps : {type: "1f" , value: mod.steps.value }, 
						rendType : {type: "1f" , value: mod.rendType}, 
						xLimit1 : {type: "1f" , value: mod.xLimit1 }, 
						xLimit2 : {type: "1f" , value: mod.xLimit2 }, 
						yLimit1 : {type: "1f" , value: mod.yLimit1 }, 
						yLimit2 : {type: "1f" , value: mod.yLimit2 }, 
						zLimit1 : {type: "1f" , value: mod.zLimit1 }, 
						zLimit2 : {type: "1f" , value: mod.zLimit2 }, 
						alphaCorrection : {type: "1f" , value: mod.alphaCorrection.value}}
			});

		meshSecondPass.material=materialSecondPass;
		meshSecondPass.material.needsUpdate = true;

		redraw();
		//test performance
		mod.tend = Date.now();
		var dt = mod.tend-mod.tstart;
		// outputs.messageLog.event(dt/1000);

	}
	mod.updateShaderFunction=updateShaderFunction;
	//
   	//controls
   	//
   	function drag(deltaX, deltaY) {
		var radPerPixel = (Math.PI / 450),
			deltaPhi = radPerPixel * deltaX,
			deltaTheta = radPerPixel * deltaY,
			pos = camera.position.sub(center),
			radius = pos.length(),
			theta = Math.acos(pos.z / radius),
			phi = Math.atan2(pos.y, pos.x);

		// Subtract deltaTheta and deltaPhi
		theta = Math.min(Math.max(theta - deltaTheta, 0), Math.PI);
		phi -= deltaPhi;

		// Turn back into Cartesian coordinates
		pos.x = radius * Math.sin(theta) * Math.cos(phi);
		pos.y = radius * Math.sin(theta) * Math.sin(phi);
		pos.z = radius * Math.cos(theta);

		camera.position.add(center);
		camera.lookAt(center);
		redraw();
	}

	///
	function zoomIn() {
		camera.position.sub(center).multiplyScalar(0.9).add(center);
		redraw();
	}

	///
	function zoomOut() {
		camera.position.sub(center).multiplyScalar(1.1).add(center);
		redraw();
	}
}

//
// return values
//
return ({
   name:name,
   init:init,
   inputs:inputs,
   outputs:outputs,
   interface:interface
   });
}());
