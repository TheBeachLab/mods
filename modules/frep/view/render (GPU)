//
// view density field threejs
//
// Neil Gershenfeld 
// (c) Massachusetts Institute of Technology 2016
// 
// This work may be reproduced, modified, distributed, performed, and 
// displayed for any purpose, but must acknowledge the mods
// project. Copyright is retained and must be preserved. The work is 
// provided as is; no warranty is provided, and users accept all 
// liability.
//
//
// closure
//
(function(){
//
// module globals
//
var mod = {};
//
// name
//
var name = 'volume renderer';
//
// initialization
//
var init = function() {
         mod.width = 40;
         mod.height = 40;
         mod.depth = 40;
   };
//
// inputs
//
var inputs = {
   data:{type:'object',
      event:function(evt){
         }}};
//
// outputs
//
var outputs = {
    messageLog:{type:'string',
      event:function(mess){
         //mess='hshs' 
         mods.output(mod,'messageLog',mess);
      }
    }
};
//
// interface
//
var interface = function(div){
   mod.div = div;
   //
   // info
   //
   //
   // view
   //   
   div.appendChild(document.createElement('br'))  ; 
   var btn = document.createElement('button');
      btn.style.padding = mods.ui.padding;
      btn.style.margin = 1;
      var span = document.createElement('span');
         var text = document.createTextNode('view');
            span.appendChild(text);
         btn.appendChild(span);
      btn.addEventListener('click',function(){
         open_view_window();
         });
      div.appendChild(btn);
   };
//
// local functions
//
 
//
// open_view_window
//
function open_view_window() {
   //
   // globals
   //
    var container;
    var camera, sceneFirstPass, sceneSecondPass, renderer;
	var clock ;
	var rtTexture;
	var histogram = [];
	var guiControls;
	var materialSecondPass;
	var center = new THREE.Vector3(0,0,0);
   //
   // open the window
   //
   addShaderScripts();
   outputs.messageLog.event('open');
   open_window();
   
   //
   // open_window
   //
   function open_window() {
      //
      // open window
	  //
	  
      win = window.open('');
      mod.win = win;
      //
      // load three.js
      //
      var script = document.createElement('script');
      script.type = 'text/javascript';
      script.onload = init_window;
      script.src = 'js/three.js/three.min.js';
      mod.div.appendChild(script);
	  }
   //
   // add shader scripts
   //
   function addShaderScripts() {

	/////////////////////////fragmentShaderFirstPass////////////////////////////////////

    var div = document.createElement('script');

	div.id = 'fragmentShaderFirstPass';
	div.type = 'x-shader/x-fragment';

    div.innerHTML =
		`
			varying vec3 worldSpaceCoords;

			void main()
			{
				//The fragment's world space coordinates as fragment output.
				gl_FragColor = vec4( worldSpaceCoords.x , worldSpaceCoords.y, worldSpaceCoords.z, 1 );
			}
			`;
	
	//
	mod.div.appendChild(div);
	
	/////////////////////////vertexShaderFirstPass////////////////////////////////////
	var div = document.createElement('script');

	div.id = 'vertexShaderFirstPass';
	div.type = 'x-shader/x-vertex';

    div.innerHTML =
		`
			varying vec3 worldSpaceCoords;

			void main()
			{
				//Set the world space coordinates of the back faces vertices as output.
				worldSpaceCoords = position + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
			`;
	
	//
	mod.div.appendChild(div);
	/////////////////////////fragmentShaderSecondPass////////////////////////////////////
	var div = document.createElement('script');

	div.id = 'fragmentShaderSecondPass';
	div.type = 'x-shader/x-fragment';

    div.innerHTML =
		`
			varying vec3 worldSpaceCoords;
			varying vec4 projectedCoords;
			uniform sampler2D tex;
			uniform float steps;
			uniform float alphaCorrection;
			// The maximum distance through our rendering volume is sqrt(3).
			// The maximum number of steps we take to travel a distance of 1 is 512.
			// ceil( sqrt(3) * 512 ) = 887
			// This prevents the back of the image from getting cut off when steps=512 & viewing diagonally.
			const int MAX_STEPS = 887;

			//Acts like a texture3D using Z slices and trilinear filtering.
			vec4 sampleAs3DTextureCustom( vec3 texCoord )
			{ 
				vec3 c;
				c.x=0.5;
				c.y=0.5;
				c.z=0.5;

				vec4 m;
				m.r=texCoord.x;
				m.g=texCoord.y;
				m.b=texCoord.z;
				//m.a= distance(c,texCoord)/2.0;
				if(distance(c,texCoord)>0.5)
				{
				   m.a= 0.0;

				}else
				{
				   m.a= 1.0;
				}

				return m ;
			}


			void main( void ) {

				//Transform the coordinates it from [-1;1] to [0;1]
				vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,
								((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0 );

				//The back position is the world space position stored in the texture.
				vec3 backPos = texture2D(tex, texc).xyz;

				//The front position is the world space position of the second render pass.
				vec3 frontPos = worldSpaceCoords;

				//The direction from the front position to back position.
				vec3 dir = backPos - frontPos;

				float rayLength = length(dir);

				//Calculate how long to increment in each step.
				float delta = 1.0 / steps;

				//The increment in each direction for each step.
				vec3 deltaDirection = normalize(dir) * delta;
				float deltaDirectionLength = length(deltaDirection);

				//Start the ray casting from the front position.
				vec3 currentPosition = frontPos;

				//The color accumulator.
				vec4 accumulatedColor = vec4(0.0);

				//The alpha value accumulated so far.
				float accumulatedAlpha = 0.0;

				//How long has the ray travelled so far.
				float accumulatedLength = 0.0;

				//If we have twice as many samples, we only need ~1/2 the alpha per sample.
				//Scaling by 256/10 just happens to give a good value for the alphaCorrection slider.
				float alphaScaleFactor = 25.6 * delta;

				vec4 colorSample;
				float alphaSample;

				//Perform the ray marching iterations
				for(int i = 0; i < MAX_STEPS; i++)
				{
					//Get the voxel intensity value from the 3D texture.
					colorSample = sampleAs3DTextureCustom( currentPosition );

					//Allow the alpha correction customization.
					alphaSample = colorSample.a * alphaCorrection;

					//Applying this effect to both the color and alpha accumulation results in more realistic transparency.
					alphaSample *= (1.0 - accumulatedAlpha);

					//Scaling alpha by the number of steps makes the final color invariant to the step size.
					alphaSample *= alphaScaleFactor;

					//Perform the composition.
					accumulatedColor += colorSample * alphaSample;

					//Store the alpha accumulated so far.
					accumulatedAlpha += alphaSample;

					//Advance the ray.
					currentPosition += deltaDirection;
					accumulatedLength += deltaDirectionLength;

					//If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.
					if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )
						break;
				}

				gl_FragColor  = accumulatedColor;

			}
			`;
	
	//
	mod.div.appendChild(div);

	/////////////////////vertexShaderSecondPass///////////////////
	var div = document.createElement('script');

	div.id = 'vertexShaderSecondPass';
	div.type = 'x-shader/x-vertex';

    div.innerHTML =
		`
			varying vec3 worldSpaceCoords;
			varying vec4 projectedCoords;

			void main()
			{
				worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;
				gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );
				projectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
			`;
	//
	mod.div.appendChild(div);

	}
   
	
	//
   
	//
   //
   //controls
   //
   function drag(deltaX, deltaY) {
		var radPerPixel = (Math.PI / 450),
			deltaPhi = radPerPixel * deltaX,
			deltaTheta = radPerPixel * deltaY,
			pos = camera.position.sub(center),
			radius = pos.length(),
			theta = Math.acos(pos.z / radius),
			phi = Math.atan2(pos.y, pos.x);

		// Subtract deltaTheta and deltaPhi
		theta = Math.min(Math.max(theta - deltaTheta, 0), Math.PI);
		phi -= deltaPhi;

		// Turn back into Cartesian coordinates
		pos.x = radius * Math.sin(theta) * Math.cos(phi);
		pos.y = radius * Math.sin(theta) * Math.sin(phi);
		pos.z = radius * Math.cos(theta);

		camera.position.add(center);
		camera.lookAt(center);
		redraw();
	}

	function zoomIn() {
		camera.position.sub(center).multiplyScalar(0.9).add(center);
		redraw();
	}

	function zoomOut() {
		camera.position.sub(center).multiplyScalar(1.1).add(center);
		redraw();
	}
	//
   // init_window
   //
   function init_window() {
      //
      // close button
      //
      var btn = document.createElement('button');
         btn.appendChild(document.createTextNode('close'));
         btn.style.padding = mods.ui.padding;
         btn.style.margin = 1;
         btn.addEventListener('click',function(){
            win.close();
            mod.win = undefined;
            });
         win.document.body.appendChild(btn);
      //
      // label text
      //
      var text = win.document.createTextNode(' left: pan, right: rotate, scroll: zoom');
         win.document.body.appendChild(text);
      //
      // GL container
      //
      win.document.body.appendChild(document.createElement('br')) ;  
      container = win.document.createElement('div');
      container.style.overflow = 'hidden';
      win.document.body.appendChild(container);
      
	  //
	  //
	  //Parameters that can be modified.
	guiControls = new function() {
		this.model = 'bonsai';
		this.steps = 256.0;
		this.alphaCorrection = 1.0;
		this.color1 = "#00FA58";
		this.stepPos1 = 0.1;
		this.color2 = "#CC6600";
		this.stepPos2 = 0.7;
		this.color3 = "#F2F200";
		this.stepPos3 = 1.0;
	}
	
	clock = new THREE.Clock();
	//
	// add camera
	//
	camera = new THREE.PerspectiveCamera( 40, win.innerWidth / win.innerHeight, 0.01, 3000.0 );
	camera.position.z = 2.0;
	 
	var screenSize = new THREE.Vector2( win.innerWidth, win.innerHeight );
	rtTexture = new THREE.WebGLRenderTarget( screenSize.x, screenSize.y,
											{ 	minFilter: THREE.LinearFilter,
												magFilter: THREE.LinearFilter,
												wrapS:  THREE.ClampToEdgeWrapping,
												wrapT:  THREE.ClampToEdgeWrapping,
												format: THREE.RGBFormat,
												type: THREE.FloatType,
												generateMipmaps: false} );


	var materialFirstPass = new THREE.ShaderMaterial( {
		vertexShader: document.getElementById( 'vertexShaderFirstPass' ).textContent,
		fragmentShader: document.getElementById( 'fragmentShaderFirstPass' ).textContent,
		side: THREE.BackSide
	} );

	materialSecondPass = new THREE.ShaderMaterial( {
		vertexShader: document.getElementById( 'vertexShaderSecondPass' ).textContent,
		fragmentShader: document.getElementById( 'fragmentShaderSecondPass' ).textContent,
		side: THREE.FrontSide,
		uniforms: {	tex:  { type: "t", value: rtTexture },
					steps : {type: "1f" , value: guiControls.steps },
					alphaCorrection : {type: "1f" , value: guiControls.alphaCorrection }}
		});

	
	outputs.messageLog.event('s');

	sceneFirstPass = new THREE.Scene();
	sceneSecondPass = new THREE.Scene();

	var boxGeometry = new THREE.BoxGeometry(1.0, 1.0, 1.0);
	boxGeometry.doubleSided = true;

	var meshFirstPass = new THREE.Mesh( boxGeometry, materialFirstPass );
	var meshSecondPass = new THREE.Mesh( boxGeometry, materialSecondPass );

	sceneFirstPass.add( meshFirstPass );
	sceneSecondPass.add( meshSecondPass );

	renderer = new THREE.WebGLRenderer();
	container.appendChild( renderer.domElement );


	camera.aspect = win.innerWidth / win.innerHeight;
	
	//
	// fit camera and controls
	//
	camera.up = new THREE.Vector3(0, 0, 1);
	camera.position.x = 5;
	camera.lookAt(new THREE.Vector3(0,0,0));
	camera.updateProjectionMatrix();

	var Controls = (function(Controls) {
		// "use strict";
	
		// Check for double inclusion
		if (Controls.addMouseHandler)
			return Controls;
	
		Controls.addMouseHandler = function (domObject, drag, zoomIn, zoomOut) {
			var startDragX = null,
				startDragY = null;
	
			function mouseWheelHandler(e) {
				e = window.event || e;
				var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
	
				if (delta < 0 && zoomOut) {
					zoomOut(delta);
				} else if (zoomIn) {
					zoomIn(delta);
				}
	
				e.preventDefault();
			}
	
			function mouseDownHandler(e) {
				startDragX = e.clientX;
				startDragY = e.clientY;
	
				e.preventDefault();
			}
	
			function mouseMoveHandler(e) {
				if (startDragX === null || startDragY === null)
					return;
	
				if (drag)
					drag(e.clientX - startDragX, e.clientY - startDragY);
	
				startDragX = e.clientX;
				startDragY = e.clientY;
	
				e.preventDefault();
			}
	
			function mouseUpHandler(e) {
				mouseMoveHandler.call(this, e);
				startDragX = null;
				startDragY = null;
	
				e.preventDefault();
			}
	
			domObject.addEventListener("mousewheel", mouseWheelHandler);
			domObject.addEventListener("DOMMouseScroll", mouseWheelHandler);
			domObject.addEventListener("mousedown", mouseDownHandler);
			domObject.addEventListener("mousemove", mouseMoveHandler);
			domObject.addEventListener("mouseup", mouseUpHandler);
		};
		return Controls;
	}(Controls || {}));
	
	Controls.addMouseHandler(renderer.domElement, drag, zoomIn, zoomOut);
	// Controls.addMouseHandler(container, drag, zoomIn, zoomOut);

	//
	//
	//
	renderer.setSize( win.innerWidth, win.innerHeight );
	//
	//
	//
	 //animate();
	 render();
	}
  
  
	/////////////// 
	function onWindowResize( event ) {

		camera.aspect = win.innerWidth / win.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( win.innerWidth, win.innerHeight );
	}

    ////////////////
	function animate() {
		requestAnimationFrame( animate );
		render();
	}

	function redraw(){
		render();
	}

    //////////////////
	function render() {

		var delta = clock.getDelta();

		//Render first pass and store the world space coords of the back face fragments into the texture.
		renderer.render( sceneFirstPass, camera, rtTexture, true );

		//Render the second pass and perform the volume rendering.
		renderer.render( sceneSecondPass, camera );

		materialSecondPass.uniforms.steps.value = guiControls.steps;
		materialSecondPass.uniforms.alphaCorrection.value = guiControls.alphaCorrection;
	}
	////////
	////////
	

}


	
//
// return values
//
return ({
   name:name,
   init:init,
   inputs:inputs,
   outputs:outputs,
   interface:interface
   })
}())
